;---------------------------------------------------------------------------------------------------
; Прерывание 14h - Сервис последовательного порта (RS-232)
; Функции:
;   AH = 00h - Инициализация порта (установка скорости, формата данных)
;   AH = 01h - Отправка символа через последовательный порт
;   AH = 02h - Прием символа из последовательного порта
;   AH = 03h - Получение статуса последовательного порта
;
; МС1502 использует нестандартный UART с портами:
;   Базовый порт: 28h (вместо стандартных 3F8h для COM1 или 2F8h для COM2)
;   Возможно, это адаптер КР580ВВ51 (советский аналог 8251)
;---------------------------------------------------------------------------------------------------
proc		int_14h
                sti                             ; Разрешаем прерывания
                push	bx                      ; Сохраняем регистры
                push	cx
                push	dx
                mov	dx, 28h                 ; Базовый порт UART МС1502 (28h)
                
                ; Проверяем запрошенную функцию по значению в AH
                or	ah, ah                  ; AH = 00h?
                jnz	short check_send_function   ; Нет - проверяем другие функции
                
                ; ---------------------------------------------------------------------------
                ; Функция 00h: Инициализация последовательного порта
                ; Вход: AL = параметры инициализации:
                ;   Биты 7-5: скорость передачи (бодрейт)
                ;   Биты 4-3: контроль четности (00/10 = нет, 01 = нечет, 11 = чет)
                ;   Бит 2: количество стоп-битов (0 = 1, 1 = 2)
                ;   Биты 1-0: длина слова (00 = 5 бит, 01 = 6, 10 = 7, 11 = 8)
                ; Выход: AH = статус порта, AL = настройки модема
                ; ---------------------------------------------------------------------------
initialize_port_func:				; ...
                push	ax                      ; Сохраняем параметры инициализации
                mov	ah, al                  ; Копируем параметры в AH
                
                ; Настраиваем таймер 8253 для генерации скорости передачи
                mov	al, 76h                 ; Команда таймера: канал 1, режим 3, двоичный
                out	43h, al                 ; Порт команд таймера 8253
                
                ; Вычисляем скорость передачи из параметров
                xor	bx, bx                  ; Очищаем BX
                mov	bl, ah                  ; Копируем параметры в BL
                mov	cl, 4                   ; Для сдвига битов скорости
                rol	bl, cl                  ; Сдвигаем биты 7-5 в позицию 1-3
                and	bl, 0Eh                 ; Маска: оставляем 3 бита скорости
                
                ; Загружаем значение делителя таймера для выбранной скорости
                mov	ax, cs:baud_rates_table[bx] ; Получаем делитель из таблицы
                out	41h, al                 ; Загружаем младший байт в таймер
                mov	al, ah
                out	41h, al                 ; Загружаем старший байт в таймер
                
                ; Инициализация UART: последовательность команд для сброса
                inc	dx                      ; DX = 29h (порт команд/статуса UART)
                mov	al, 65h                 ; Команда сброса
                out	dx, al                  ; Отправляем команду сброса
                call	short_delay           ; Небольшая задержка
                
                mov	al, 5                   ; Следующая команда инициализации
                out	dx, al
                call	short_delay
                
                mov	al, 65h                 ; Еще одна команда сброса
                out	dx, al
                call	short_delay
                
                ; Восстанавливаем параметры и формируем команду для UART
                pop	ax                      ; Восстанавливаем исходные параметры
                or	ah, 4Ah                 ; Базовые настройки: 8 бит данных, контроль четности?
                
                ; Обрабатываем бит длины слова (биты 1-0)
                test	al, 1                  ; Проверяем младший бит длины
                jz	short check_stop_bits   ; Если 0, оставляем как есть
                or	ah, 4                   ; Устанавливаем соответствующий бит

check_stop_bits:				; ...
                ; Обрабатываем бит количества стоп-битов (бит 2)
                test	al, 4                  ; Проверяем бит стоп-битов
                jz	short check_parity      ; Если 0, оставляем
                or	ah, 80h                 ; Устанавливаем бит для 2 стоп-битов

check_parity:				; ...
                ; Обрабатываем биты контроля четности (биты 4-3)
                test	al, 8                  ; Проверяем наличие контроля четности
                jz	short send_uart_command ; Если нет контроля четности
                or	ah, 10h                 ; Устанавливаем бит контроля четности
                test	al, 10h                ; Проверяем тип четности (четная/нечетная)
                jz	short send_uart_command ; Если 0, оставляем
                or	ah, 20h                 ; Устанавливаем бит для четной четности

send_uart_command:				; ...
                ; Отправляем финальную команду конфигурации в UART
                mov	al, ah                  ; Команда конфигурации
                out	dx, al                  ; Порт команд UART (29h)
                call	short_delay           ; Задержка
                
                mov	al, 27h                 ; Команда включения передачи/приема
                out	dx, al
                dec	dx                      ; Восстанавливаем DX = 28h (порт данных)
                jmp	get_port_status         ; Возвращаем статус порта

; ---------------------------------------------------------------------------
; Проверка других функций прерывания
; ---------------------------------------------------------------------------
check_send_function:				; ...
                dec	ah                      ; AH = 01h?
                jz	short send_char_func    ; Да - отправка символа
                dec	ah                      ; AH = 02h?
                jz	short receive_char_func ; Да - прием символа
                dec	ah                      ; AH = 03h?
                jnz	short unknown_function  ; Нет - неизвестная функция
                jmp	get_port_status         ; AH = 03h - получение статуса

unknown_function:				; ...
                jmp	return_with_error       ; Неизвестная функция - возврат с ошибкой

; ---------------------------------------------------------------------------
; Функция 01h: Отправка символа через последовательный порт
; Вход: AL = символ для отправки, DX = номер порта (0 для COM1, 1 для COM2)
; Выход: AH = статус порта (бит 7 = 1 при таймауте)
; ---------------------------------------------------------------------------
send_char_func:				; ...
                mov	ah, 0                   ; Очищаем старший байт статуса
                push	ax                      ; Сохраняем символ
                
                inc	dx                      ; DX = 29h (порт команд/статуса)
                mov	al, 27h                 ; Команда включения передачи
                out	dx, al
                
                ; Ожидание готовности передатчика (бит 7 статуса = 1)
                xor	cx, cx                  ; Счетчик для таймаута

wait_tx_ready:				; ...
                in	al, dx                  ; Читаем статус
                test	al, 80h                 ; Проверяем бит готовности передатчика
                jnz	short tx_is_ready       ; Готов
                loop	wait_tx_ready          ; Продолжаем ожидание
                
                ; Таймаут - передатчик не готов
                pop	ax                      ; Восстанавливаем стек
                jmp	short timeout_exit      ; Выход с ошибкой таймаута

tx_is_ready:				; ...
                ; Ожидание готовности линии данных (бит 0 статуса = 1)
                xor	cx, cx

wait_data_ready:				; ...
                in	al, dx                  ; Читаем статус
                test	al, 1                   ; Проверяем бит готовности данных
                jnz	short send_actual_char  ; Готово
                loop	wait_data_ready        ; Продолжаем ожидание
                
                ; Таймаут - линия не готова
                pop	ax
                jmp	short timeout_exit

send_actual_char:				; ...
                ; Отправляем символ
                dec	dx                      ; DX = 28h (порт данных)
                pop	ax                      ; Восстанавливаем символ
                out	dx, al                  ; Отправляем символ
                jmp	short return_success    ; Успешный выход

timeout_exit:				; ...
                or	ah, 80h                 ; Устанавливаем бит таймаута

return_success:				; ...
                pop	dx                      ; Восстанавливаем регистры
                pop	cx
                pop	bx
                iret

; ---------------------------------------------------------------------------
; Функция 02h: Прием символа из последовательного порта
; Вход: DX = номер порта (0 для COM1, 1 для COM2)
; Выход: AL = принятый символ, AH = статус порта (бит 7 = 1 при таймауте)
; ---------------------------------------------------------------------------
receive_char_func:				; ...
                mov	ah, 0                   ; Очищаем старший байт статуса
                xor	cx, cx                  ; Счетчик для таймаута
                inc	dx                      ; DX = 29h (порт команд/статуса)

                ; Ожидание готовности приемника (бит 2 статуса = 1)
wait_rx_ready:				; ...
                in	al, dx                  ; Читаем статус
                test	al, 4                   ; Проверяем бит готовности приемника
                jnz	short rx_is_ready       ; Готов
                loop	wait_rx_ready          ; Продолжаем ожидание
                jmp	short timeout_exit      ; Таймаут

rx_is_ready:				; ...
                mov	al, 27h                 ; Команда включения приема
                out	dx, al
                
                ; Ожидание данных в приемнике (бит 7 статуса = 1)
                xor	cx, cx

wait_rx_data:				; ...
                in	al, dx                  ; Читаем статус
                test	al, 80h                 ; Проверяем бит наличия данных
                jnz	short check_rx_error    ; Данные есть
                loop	wait_rx_data          ; Продолжаем ожидание
                jmp	short timeout_exit      ; Таймаут

check_rx_error:				; ...
                ; Проверяем ошибки приема (бит 1 статуса)
                xor	cx, cx

wait_error_check:				; ...
                in	al, dx                  ; Читаем статус
                test	al, 2                   ; Проверяем бит ошибки
                jz	short read_data         ; Ошибок нет
                loop	wait_error_check      ; Ждем сброса ошибки
                jmp	short timeout_exit      ; Таймаут

read_data:				; ...
                ; Обрабатываем полученные данные
                and	al, 78h                 ; Маскируем биты ошибок (01111000b)
                mov	cl, 3
                shr	al, cl                  ; Сдвигаем биты ошибок в младшие разряды
                
                ; Преобразуем код ошибки через таблицу
                mov	bx, offset error_status_table
                xlat	[byte ptr cs:bx]        ; Преобразуем код ошибки
                mov	ah, al                  ; Сохраняем статус ошибки в AH
                
                ; Читаем принятый символ
                dec	dx                      ; DX = 28h (порт данных)
                in	al, dx                  ; Читаем принятый символ
                inc	dx                      ; DX = 29h (порт команд/статуса)
                mov	bl, al                  ; Сохраняем символ в BL
                
                mov	al, 37h                 ; Команда сброса состояния приемника
                out	dx, al
                mov	al, bl                  ; Восстанавливаем символ в AL
                jmp	return_success          ; Успешный выход

; ---------------------------------------------------------------------------
; Процедура короткой задержки (для стабилизации сигналов UART)
; ---------------------------------------------------------------------------
short_delay:				; ...
                mov	cx, 14h                ; Время задержки

delay_loop:				; ...
                loop	delay_loop
                retn

; ---------------------------------------------------------------------------
; Функция 03h: Получение статуса последовательного порта
; Вход: DX = номер порта (0 для COM1, 1 для COM2)
; Выход: AH = статус линии (готовность, ошибки), AL = статус модема
; ---------------------------------------------------------------------------
get_port_status:				; ...
                inc	dx                      ; DX = 29h (порт команд/статуса)
                in	al, dx                  ; Читаем статус порта
                mov	ch, al                  ; Сохраняем статус в CH
                
                ; Обрабатываем биты статуса линии
                mov	cl, 2
                shr	ch, cl                  ; Сдвигаем бит 2 в бит 0
                and	ch, 20h                 ; Изолируем бит 5 (возможно, бит Break)
                
                ; Преобразуем биты формата данных (биты 2-0) через таблицу
                mov	bx, offset data_format_table
                mov	ah, al                  ; Копируем статус в AH
                and	al, 7                   ; Изолируем биты 2-0 (длина слова, стоп-биты)
                xlat	[byte ptr cs:bx]        ; Преобразуем
                xchg	ah, al                  ; Меняем местами: AL=статус, AH=формат
                
                ; Преобразуем биты скорости и контроля четности (биты 7-3)
                mov	cl, 3
                shr	al, cl                  ; Сдвигаем биты 7-3 в позицию 4-0
                and	al, 0Fh                 ; Маска 4 бита
                mov	bx, offset line_status_table
                xlat	[byte ptr cs:bx]        ; Преобразуем
                or	ah, al                  ; Объединяем с форматом данных
                
                ; Добавляем бит Break из CH
                or	ah, ch                  ; Добавляем бит Break (если есть)
                
                ; Читаем статус модема (регистр управления/статуса модема)
                inc	dx                      ; DX = 2Ah (порт модема)
                mov	al, 0F0h                ; Команда чтения статуса модема?
                jmp	return_success          ; Выход со статусом

return_with_error:				; ...
                pop	dx                      ; Восстанавливаем регистры
                pop	cx
                pop	bx
                iret

; ---------------------------------------------------------------------------
; Таблица делителей для скоростей передачи (бодрейтов)
; Значения для таймера 8253 (частота 1.19318 МГц)
; ---------------------------------------------------------------------------
baud_rates_table:
                dw    0470h    ; 110 бод
                dw    0341h    ; 150 бод
                dw    01A1h    ; 300 бод
                dw    00D0h    ; 600 бод
                dw    0068h    ; 1200 бод
                dw    0034h    ; 2400 бод
                dw    001Ah    ; 4800 бод
                dw    000Dh    ; 9600 бод

; ---------------------------------------------------------------------------
; Таблица преобразования статуса ошибок
; Преобразует биты ошибок UART в стандартные коды ошибок PC
; ---------------------------------------------------------------------------
error_status_table:
                db    00h     ; Нет ошибок
                db    04h     ; Ошибка четности
                db    02h     ; Ошибка фрейма (стоп-бит)
                db    06h     ; Ошибка четности + фрейма
                db    08h     ; Break-сигнал
                db    0Ch     ; Break + ошибка четности
                db    0Ah     ; Break + ошибка фрейма
                db    0Eh     ; Break + ошибка четности + фрейма
                db    10h     ; Переполнение буфера
                db    14h     ; Переполнение + ошибка четности
                db    12h     ; Переполнение + ошибка фрейма
                db    16h     ; Переполнение + ошибка четности + фрейма
                db    18h     ; Break + переполнение
                db    1Ch     ; Break + переполнение + ошибка четности
                db    1Ah     ; Break + переполнение + ошибка фрейма
                db    1Eh     ; Break + переполнение + ошибка четности + фрейма

; ---------------------------------------------------------------------------
; Таблица преобразования формата данных
; Преобразует биты 2-0 статуса в информацию о формате данных
; ---------------------------------------------------------------------------
data_format_table:
                db    00h     ; 5 бит, 1 стоп-бит, нет контроля четности
                db    04h     ; 6 бит, 1 стоп-бит, нет контроля четности
                db    02h     ; 7 бит, 1 стоп-бит, нет контроля четности
                db    06h     ; 8 бит, 1 стоп-бит, нет контроля четности
                db    08h     ; 5 бит, 2 стоп-бита, нет контроля четности
                db    0Ch     ; 6 бит, 2 стоп-бита, нет контроля четности
                db    0Ah     ; 7 бит, 2 стоп-бита, нет контроля четности
                db    0Eh     ; 8 бит, 2 стоп-бита, нет контроля четности

; ---------------------------------------------------------------------------
; Таблица статуса линии (скорость + контроль четности)
; Преобразует биты 7-3 статуса в информацию о скорости и контроле четности
; ---------------------------------------------------------------------------
line_status_table:
                db    00h     ; Скорость 1 + нет контроля четности
                db    04h     ; Скорость 1 + контроль нечетности
                db    02h     ; Скорость 1 + контроль четности
                db    06h     ; Скорость 1 + всегда 1
                db    08h     ; Скорость 2 + нет контроля четности
                db    0Ch     ; Скорость 2 + контроль нечетности
                db    0Ah     ; Скорость 2 + контроль четности
                db    0Eh     ; Скорость 2 + всегда 1
                db    10h     ; Скорость 3 + нет контроля четности
                db    14h     ; Скорость 3 + контроль нечетности
                db    12h     ; Скорость 3 + контроль четности
                db    16h     ; Скорость 3 + всегда 1
                db    18h     ; Скорость 4 + нет контроля четности
                db    1Ch     ; Скорость 4 + контроль нечетности
                db    1Ah     ; Скорость 4 + контроль четности
                db    1Eh     ; Скорость 4 + всегда 1
endp		int_14h
