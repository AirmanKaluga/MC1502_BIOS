	Ideal				; Директива режима идеального ассемблера (TASM)
	model small			; Модель памяти small (производит .EXE, затем обрезается)
;---------------------------------------------------------------------------------------------------
; Macros				; Заголовок раздела макросов
;---------------------------------------------------------------------------------------------------
; Pad code to create entry point at specified address (needed for 100% IBM BIOS compatibility)
macro	entry	addr			; Макрос для создания точки входа по указанному адресу
	pad = str_banner - $ + addr - 0E000h	; Вычисление размера заполнения до нужного адреса
	if pad lt 0				; Если места недостаточно
		err	'No room for ENTRY point'	; Сообщить об ошибке
	endif					; Конец условия
	if pad gt 0				; Если нужно заполнить
		db	pad dup(090h)		; Заполнить NOP-ами (код 90h)
	endif					; Конец условия
endm					; Конец макроса

macro	jmpfar	segm, offs			; Макрос дальнего перехода
        db	0EAh				; Код операции JMP FAR
        dw	offs, segm			; Смещение и сегмент
endm					; Конец макроса

;---------------------------------------------------------------------------------------------------
include	var.asm				; Подключение файла с переменными
;---------------------------------------------------------------------------------------------------


; Segment type:	Pure code			; Тип сегмента: чистый код
segment		code byte public 'CODE'	; Сегмент кода, байтовый, публичный, класс 'CODE'
                assume cs:code			; CS указывает на сегмент code
                org 0E000h			; Начало с адреса E000h (внутри сегмента)
                assume es:nothing, ss:nothing, ds:nothing ; Никаких предположений о других сегментах


Banner:						; Метка баннера (заголовок BIOS)
str_banner      db ' 8088/8086/V20/V30 Modular BIOS v7.3', 0 ; Строка с версией BIOS, завершается нулём

date_full:					; Метка полной даты
		db LF, CR, ' Released 12/04/2020 by Airman and RUS' , 0 ; Строка с датой релиза, перевод строки, возврат каретки

enter_setup:					; Метка приглашения для входа в Setup
		db ' Press <DEL> to Enter Setup', 0 ; Текст "Нажмите DEL для входа в Setup"
Copyright:					; Метка копирайта
		db LF, CR, ' Copyright (C) 1989-2020, NPO "Microprocessor" 1989', LF, CR, 0 ; Копирайт
empty_string:					; Метка пустой строки
		db LF, CR, 0			; Только перевод строки и возврат каретки
platform_string:				; Метка строки платформы
		db LF, CR, ' ELECTRONIKA MC1502', 0 ; Название компьютера

str_8088:					; Строка для процессора 8088
	 	db LF, CR, LF, CR,' Intel (C) 8088 at 5.33 Mhz', 0 ; "Intel 8088 на 5.33 МГц"
str_v20:                                                  	; Строка для процессора V20
		db LF, CR, LF, CR,' NEC (C) V20 at 5.33 Mhz', 0 ; "NEC V20 на 5.33 МГц"
str_8087:					; Строка для сопроцессора 8087
		db ' with Intel (C) 8087 FPU', 0 ; "с Intel 8087 FPU"
StrTestingSystem:				; Строка тестирования системы
		db ' Memory testing: 000K OK', 0 ; "Тест памяти: 000K OK"
StrEnteringSetup:				; Строка входа в Setup
		db CR, LF, CR, LF, CR, LF, ' Entering Setup...', CR, LF, LF, 0 ; "Вход в Setup..."
SkipMemTest:					; Строка пропуска теста памяти
		db ' Press <ESC> to skip memory test', 0 ; "Нажмите ESC для пропуска теста памяти"
FailedAt:					; Строка для сообщения об ошибке
		db  LF, CR, ' Failed at ', 0 ; "Ошибка по адресу "
SystemNotFound:					; Строка "Система не найдена"
		db  LF, CR, ' System not found.', LF, CR, 0

str_ega_vga:					; Строка для видео EGA/VGA
		db LF, CR, LF, CR, ' EGA/VGA Video card Installed          ', LF, CR, 0
str_cga:					; Строка для видео CGA
		db LF, CR, LF, CR, ' CGA Video card installed              ', LF, CR, 0

str_ins_disk:	db ' Insert BOOT disk in A:', CR, LF ; Вставьте загрузочный диск в A:
		db ' Press any key when ready', CR, LF, LF, 0 ; Нажмите любую клавишу, когда будете готовы

port_int_fdc:					; Таблица внутренних портов FDC (контроллера дисковода)
                db  48h	 		; 48h
                db  4Ch			; 4Ch
                db  4Eh			; 4Eh
                db  4Dh			; 4Dh

port_ext_fdc:					; Таблица внешних портов FDC
                db  0Ch			; 0Ch
                db  00h			; 00h
                db  08h			; 08h
                db  0Ah			; 0Ah


baud:						; Таблица значений для скорости передачи (baud rate)
		dw    470h			; 470h
                dw    341h			; 341h
                dw    1A1h			; 1A1h
                dw    0D0h			; 0D0h
                dw    068h			; 068h
                dw    034h			; 034h
                dw    01Ah			; 01Ah
                dw    00Dh			; 00Dh
BDA:						; Область данных BIOS (BDA) – начало
rs232_1:	dw    3F8h			; Базовый адрес COM1
rs232_2:	dw    0				; COM2 (отсутствует)
rs232_3:	dw    0				; COM3 (отсутствует)
rs232_4:	dw    0				; COM4 (отсутствует)
lpt_1:		dw    62h			; Базовый адрес LPT1
lpt_2:		dw    0				; LPT2 (отсутствует)
lpt_3:		dw    0				; LPT3 (отсутствует)
bios_data_seg:	dw    0				; Сегмент данных BIOS (зарезервирован)
equip_bit:	dw    622Dh			; Слово оборудования (биты конфигурации)
manufact_test:	db    0				; Байт теста производителя
main_ram_size:	dw    0				; Размер основной ОЗУ в КБ
error_codes:	dw    40h			; Коды ошибок (начальное значение 40h)
kb_flag_1:	db    0				; Флаги клавиатуры 1
kb_flag_2:	db    0				; Флаги клавиатуры 2
kb_alt_num:	db    0				; Счётчик Alt-цифр
kb_q_head:	dw  1Eh				; Голова очереди клавиатуры (начало буфера 1Eh)
kb_q_tail:	dw  1Eh				; Хвост очереди клавиатуры (начало буфера 1Eh)
kb_queue:	dw  1Eh				; Сама очередь клавиатуры (буфер)


; ---------------------------------------------------------------------------
proc		post	near			; Процедура POST (Power-On Self Test)
warm_boot:					; Точка входа при холодной/тёплой перезагрузке
                cli				; Запретить прерывания
                cld				; Сбросить флаг направления
write_first_post_codes:			; Метка записи первого кода POST
		mov	al, 01h			; AL = 01h (код POST)
		out	mfg_port, al		; Вывести в порт производства (произвольный)


@@init_PPI:					; Метка инициализации PPI (программируемый периферийный интерфейс)
                mov	al, 88h			; AL = 88h (команда для PPI)
                out	63h, al		; Порт 63h – регистр команд PPI? (PC/XT)
                                        ; Выбор режима портов PPI (порты A и C ввод, B вывод)
                mov	al, 98h			; AL = 98h
                out	6Bh, al		; Порт 6Bh – возможно, дополнительный PPI
                mov	al, 9			; AL = 9
                out	62h, al		; Порт 62h – порт C PPI, биты:
                                        ; 0-3: значения DIP-переключателей
                                        ; 5: выход таймера 2
                                        ; 6: ошибка канала ввода-вывода
                                        ; 7: ошибка чётности ОЗУ

                mov	al, 0E0h		; AL = E0h
                out	61h, al		; Порт 61h – порт B PPI:
                                        ; бит 0: управление таймером 2 (динамик)
                                        ; бит 1: данные таймера 2
                                        ; бит 3: чтение старших переключателей
                                        ; бит 4: разрешение чётности ОЗУ
                                        ; бит 5: разрешение проверки канала ввода-вывода
                                        ; бит 6: удержание тактов клавиатуры низким
                                        ; бит 7: разрешение клавиатуры
write_ppi_post_code:			; Метка записи кода POST после инициализации PPI
		
		mov	al, 02h			; AL = 02h (код POST)
		out	mfg_port, al		; Вывести в порт производства


@@init_PIC:					; Инициализация контроллера прерываний PIC (8259A)
                mov	al, 13h			; AL = 13h (команда ICW1)
                out	20h, al		; Порт 20h – команда для PIC
                mov	al, 68h			; AL = 68h (ICW2 – базовый вектор прерываний 68h?)
                out	21h, al		; Порт 21h – регистр маски PIC
                mov	al, 9			; AL = 9 (ICW4 – режим работы)
                out	21h, al		; Записать в порт 21h

write_pic_post_code:				; Метка записи кода POST после инициализации PIC
		mov	al, 03h			; AL = 03h (код POST)
		out	mfg_port, al		; Вывести в порт производства

@@init_PIT:					; Инициализация программируемого интервального таймера PIT (8253)
                mov	al, 36h			; AL = 36h (команда для канала 0 – режим 3, двоичный)
                out	43h, al		; Порт 43h – регистр команд таймера
                mov	al, 0			; AL = 0 (младший байт делителя)
                out	40h, al		; Порт 40h – канал 0 (счётчик)
                out	40h, al		; Записать старший байт (тоже 0) – делитель 10000h
                mov	al, 50h			; AL = 50h (команда для канала 1 – режим 2?)
                out	43h, al		; Записать в командный регистр
                mov	al, 4			; AL = 4 (младший байт делителя для канала 1)
                out	41h, al		; Порт 41h – канал 1
                mov	al, 0B6h		; AL = B6h (команда для канала 2 – режим 3, двоичный)
                out	43h, al		; Записать
                mov	al, 2			; AL = 2 (младший байт делителя)
                out	42h, al		; Порт 42h – канал 2
                out	42h, al		; Записать старший байт
                mov	ax, BDAseg		; AX = сегмент области данных BIOS (40h)
                mov	ds, ax			; DS = 40h
                assume ds:nothing
                xor	ax, ax			; AX = 0
                mov	ss, ax			; SS = 0 (стек в нулевом сегменте)
                mov	sp, 800h		; SP = 800h (стек размером 2 КБ)
                mov	bp, [ds:warm_boot_flag_] ; BP = флаг тёплой перезагрузки (40:72h)
                mov	di, ax			; DI = 0
                mov	es, ax			; ES = 0 (сегмент для обнуления)
                mov	cx, 380h		; CX = 380h (количество слов для обнуления)
                rep stosw			; Заполнить ES:DI нулями (очистка области данных)
                push	cs			; Поместить CS в стек
                pop	ds			; DS = CS (восстановить сегмент кода)
                assume ds:nothing

wriet_pit_post_code:				; Метка записи кода POST после инициализации PIT (опечатка: wriet)
		mov	al, 04h			; AL = 04h (код POST)
		out	mfg_port, al		; Вывести в порт производства

@@init_vec_table_1:				; Инициализация первой таблицы векторов прерываний
                mov	cx, 17h			; CX = 17h (23 вектора)
                mov	si, offset int_vec_table_1 ; SI = смещение таблицы векторов (встроенной)
                mov	di, 20h			; DI = 20h (начало векторов прерываний в памяти)

vec_table_1_loop:				; Цикл копирования векторов
                lodsw				; Загрузить слово из [CS:SI] в AX (смещение обработчика)
                stosw				; Записать в [ES:DI] (ES=0)
                mov	ax, cs			; AX = сегмент кода (CS)
                stosw				; Записать сегмент
                loop	vec_table_1_loop	; Повторить CX раз

write_fist_vec_table_code:			; Метка записи кода POST после копирования первой таблицы (опечатка: fist)
		mov	al, 05h			; AL = 05h (код POST)
		out	mfg_port, al		; Вывести в порт производства

@@init_vect_table_2:				; Инициализация второй таблицы векторов прерываний
                mov	cx, 8			; CX = 8 (8 векторов)
                mov	si, offset int_vec_table_2 ; SI = смещение второй таблицы
                mov	di, 1A0h		; DI = 1A0h (адрес векторов в памяти)

vec_table_2_loop:				; Цикл копирования
                lodsw				; Загрузить смещение
                stosw				; Записать
                mov	ax, cs			; AX = CS
                stosw				; Записать сегмент
                loop	vec_table_2_loop	; Повторить

write_secont_vec_table_code:			; Метка записи кода POST после второй таблицы (опечатка: secont)
		mov	al, 06h			; AL = 06h (код POST)
		out	mfg_port, al		; Вывести в порт производства

@@init_dummy_int:				; Инициализация фиктивного (заглушки) прерывания
                mov	di, 8			; DI = 8 (вектор 8h)
                mov	ax, offset dummy_int	; AX = смещение обработчика dummy_int
                stosw				; Записать
                mov	ax, cs			; AX = CS
                stosw				; Записать сегмент

write_dummy_int_code:				; Метка записи кода POST после инициализации dummy
		mov	al, 07h			; AL = 07h (код POST)
		out	mfg_port, al		; Вывести в порт производства


@@init_print_screen_int:			; Инициализация прерывания печати экрана (int 5)
                mov	di, 14h			; DI = 14h (вектор 5h * 4 = 14h)
                mov	ax, offset int_05h	; AX = смещение обработчика int_05h
                stosw				; Записать
                mov	ax, cs			; AX = CS
                stosw				; Записать сегмент
                mov	ax, BDAseg		; AX = сегмент BDA (40h)
                mov	es, ax			; ES = 40h
                assume es:nothing

write_print_screen_int_code:			; Метка записи кода POST после инициализации int 5
		mov	al, 08h			; AL = 08h (код POST)
		out	mfg_port, al		; Вывести в порт производства


@@init_BDA:					; Инициализация области данных BIOS (копирование из BDA в начало)
                mov	cx, 10h			; CX = 10h (16 слов)
                mov	si, offset BDA		; SI = начало области BDA в текущем сегменте
                xor	di, di			; DI = 0 (начало BDA в памяти 40:0)
                rep movsw			; Скопировать CX слов из DS:SI в ES:DI (ES=40h)

@@Test_type_fdc:				; Тест типа контроллера дисковода (внутренний/внешний)
                in	al, 4Bh			; Прочитать порт 4Bh (порт FDC)
                not	al			; Инвертировать
                out	4Bh, al			; Записать обратно
                mov	ah, al			; AH = записанное значение
                in	al, 4Bh			; Снова прочитать
                mov	si, offset port_int_fdc ; SI = таблица портов внутреннего FDC
                cmp	al, ah			; Сравнить с тем, что записали
                jz	short init_fdc_BDA	; Если совпадает – используется внутренний FDC
                mov	si, offset port_ext_fdc ; Иначе – внешний FDC

init_fdc_BDA:					; Инициализация BDA для FDC
                mov	di, 42h			; DI = 42h (адрес в BDA для портов FDC)
                movsw				; Скопировать слово из [CS:SI] в [ES:DI] (порт)
                movsw				; Скопировать следующее слово
                mov	di, 80h			; DI = 80h (адрес буфера клавиатуры?)
                mov	ax, 1Eh			; AX = 1Eh (начало буфера)
                stosw				; Записать слово (голова очереди)
                mov	ax, 3Eh			; AX = 3Eh (конец буфера)
                stosw				; Записать (хвост очереди)
                mov	al, 18h			; AL = 18h
                stosb				; Записать байт (размер буфера?)
                mov	di, 90h			; DI = 90h (область для информации о дисководах)
                xor	ax, ax			; AX = 0
                stosw				; Обнулить слово
                mov	bx, ax			; BX = 0
                mov	cx, ax			; CX = 0
                mov	di, ax			; DI = 0
                mov	ds, ax			; DS = 0 (для поиска ROM)
                assume ds:nothing
		call	search_rom		; Вызвать поиск дополнительных ROM

test_first_8K_ram:				; Тест первых 8 КБ ОЗУ
                mov	ax, [bx]		; Прочитать слово по адресу DS:BX
                not	ax			; Инвертировать
                mov	[bx], ax		; Записать обратно
                cmp	ax, [bx]		; Сравнить с прочитанным
                jnz	short Print_Startup_Info ; Если не совпадает – ошибка, перейти к печати информации
                not	[word ptr bx]		; Восстановить исходное значение
                add	ch, 8			; CH = CH + 8 (сдвиг сегмента)
                mov	ds, cx			; DS = CX (новый сегмент для следующего блока)

                assume ds:nothing
                add	di, 20h			; DI = DI + 20h (счётчик протестированной памяти)
                cmp	di, 2E0h		; Сравнить с 2E0h (конец теста?)
                jb	short test_first_8K_ram ; Если меньше – продолжить
		


Print_Startup_Info:				; Печать стартовой информации
                mov	[es:13h], di		; Сохранить DI (размер памяти?) в BDA по адресу 40:13h
                mov	al, 0FCh		; AL = FCh (маска прерываний)
                out	21h, al		; Установить маску в PIC (разрешить только некоторые прерывания)
                sti				; Разрешить прерывания
		mov	bl ,1			; BL = 1 (длина гудка)
		call 	beep			; Пикнуть
		call	video_init		; Инициализировать видео
		call	print_date		; Вывести дату
		mov	si, offset Banner	; SI = строка баннера
		call	print_string		; Вывести строку
                mov 	si, offset Copyright	; SI = строка копирайта
		call	print_string		; Вывести
		mov 	si, offset empty_string	; SI = пустая строка
		call	print_string		; Вывести перевод строки
		mov 	si, offset platform_string ; SI = строка платформы
		call	print_string		; Вывести
		call	print_cpu_fpu		; Определить и вывести тип процессора и FPU
	 	mov	dl, 00h			; DL = 0 (колонка)
		mov	dh, 09h			; DH = 9 (строка 9)
		mov	ah, 02h			; Функция установки позиции курсора
		int 	10h			; Вызов видео-прерывания
		mov	si, SkipMemTest		; SI = строка пропуска теста памяти
		call 	print_string		; Вывести
        	mov	dl, 0h			; DL = 0
		mov	dh, 07h			; DH = 7 (строка 7)
		mov	ah, 02h			; Установить курсор
		int 	10h			; Вызов
                mov	si, offset StrTestingSystem ; SI = строка "Memory testing: 000K OK"
                call	print_string		; Вывести
                mov	cx, 4h			; CX = 4 (количество пробелов для стирания)
                call	print_backspace	; Удалить 4 символа (подготовка к выводу размера)
                mov	ax, es			; AX = сегмент ES (BDA)
                mov	ds, ax			; DS = BDA
                assume ds:nothing
                xor	ax, ax			; AX = 0
                mov	bx, ax			; BX = 0
                mov	dx, ax			; DX = 0
                mov	es, ax			; ES = 0 (для теста памяти)
                assume es:nothing
				
				mov [ds:mem_test_cycle_addr], mem_test_cycle_full ; Установить адрес цикла теста (полный тест)
                jmp	short Mem_test		; Перейти к тесту памяти

; ---------------------------------------------------------------------------
Mem_test_loop:					; Цикл теста памяти
                call	Mem_test_pattern	; Выполнить тест с паттерном
                jnz	short Test_error	; Если ошибка – переход

 
Mem_test:					; Начало теста памяти (точка входа)
                mov	ax, es			; AX = текущий сегмент ES (адрес тестируемого блока)
                add	ah, 8			; Увеличить на 8 (переход к следующему блоку 8 КБ)
                mov	es, ax			; ES = новый сегмент
                assume es:nothing
                mov	ax, dx			; AX = счётчик DX
                add	al, 32h			; Добавить 32h (для вывода десятичного числа)
                daa				; Десятичная коррекция
                adc	ah, 0			; Добавить перенос
                mov	dx, ax			; DX = обновлённое значение
                mov	cx, 3			; CX = 3 (три символа для стирания)
                call	print_backspace	; Стереть 3 символа (обновление счётчика)
                mov	al, dh			; AL = старший байт (десятки?)
                call	print_AL_nibble	; Вывести старшую цифру
                mov	al, dl			; AL = младший байт
                call	print_AL		; Вывести две цифры (всего три цифры)
                add	bx, 20h			; BX = BX + 20h (сдвиг для следующего теста?)
		mov	Ah, 01h			; Функция проверки наличия символа в буфере клавиатуры
		int	16h			; Вызов прерывания клавиатуры
		jz	Mem_size_compare	; Если нет нажатия – продолжить тест
		xor	ax, ax			; AX = 0 (сброс)
		int	16h			; Прочитать символ
		cmp	al, 1Bh			; Это ESC?
		jne	Check_Del_Key		; Нет – проверить DEL
		mov word ptr [ds:mem_test_cycle_addr], mem_test_cycle_short ; Установить короткий тест (пропуск)

Check_Del_Key:					; Проверка нажатия DEL
		cmp ax, 5300h  			; Сравнить с кодом DEL (53h в AH, 00h в AL)
		jne Mem_size_compare		; Не DEL – продолжить
		mov	si, offset StrEnteringSetup ; SI = строка "Entering Setup..."
		call	print_string		; Вывести
		cli				; Запретить прерывания
		hlt				; Остановить процессор (заглушка для Setup)
	;   jmp SetupBIOS			; Заменено на hlt, но можно раскомментировать

Mem_size_compare:				; Сравнение с размером памяти
		cmp	bx, [ds:main_ram_size_]	; BX меньше сохранённого размера памяти?
		jb      short  Mem_test_loop	; Да – продолжить тест

ClearMemEscString:				; Очистка строки ESC
	 	mov	dl, 0h			; DL = 0
		mov	dh, 7h			; DH = 7 (строка 7)
		mov	ah, 02h			; Установить курсор
		int 	10h			; Вызов


Print_video_type:				; Вывод типа видео
		call	video_type		; Определить и вывести тип видео
Boot:						; Загрузка системы
                mov	si, empty_string	; SI = пустая строка
                call	print_string		; Вывести перевод строки
		mov	cx, 0Fh			; CX = 15 (количество внешних циклов задержки)
super_delay:					; Длинная задержка
		push 	cx			; Сохранить CX
		mov 	cx, 0FFFFh		; CX = 65535 (внутренний цикл)
boot_delay:					; Цикл задержки
		loop 	boot_delay		; Уменьшить CX, если не 0 – повторить
		pop 	cx			; Восстановить CX
		loop	super_delay		; Повторить внешний цикл

       		call	clear_screen		; Очистить экран
		mov	ax, 1Eh			; AX = 1Eh (начало буфера клавиатуры)
		mov	[es:1Ah], ax		; Установить голову очереди
		mov	[es:1Ch], ax		; Установить хвост очереди (очистить буфер)
                int	19h			; Вызов прерывания загрузки (перезагрузка)

Test_error:					; Обработка ошибки теста памяти
                push	ax			; Сохранить AX
                mov	si, offset FailedAt	; SI = строка "Failed at "
                call	print_string		; Вывести
                dec	di			; DI = DI - 2 (коррекция адреса ошибки)
                dec	di
                mov	ax, es			; AX = сегмент, где произошла ошибка
                call	print_AX		; Вывести сегмент
                mov	ax, 0E3Ah		; Символ ':' в AL, функция телетайпа
                int	10h			; Вывести ':'
                mov	ax, di			; AX = смещение
                call	print_AX		; Вывести смещение
                mov	ax, 0E20h		; Пробел
                int	10h			; Вывести пробел
                pop	ax			; Восстановить AX (сохранённое значение)
                xor	ax, [es:di]		; Сравнить с данными по адресу ошибки
                call	print_AX		; Вывести различие
                mov	[ds:main_ram_size_], bx	; Сохранить размер памяти до ошибки
                xor	ax, ax			; AX = 0
                int	16h			; Ожидать нажатия клавиши
endp		post				; Конец процедуры POST


proc		Mem_test_pattern near		; Процедура теста памяти с паттерном
                mov	ax, 0FFFFh		; Паттерн "все единицы"
                call	mem_test_cycle		; Выполнить цикл теста
                jnz	short sub_exit		; Если ошибка – выход
                mov	ax, 0AAAAh		; Паттерн 10101010
                call	mem_test_cycle		; Тест
                jnz	short sub_exit		; Если ошибка – выход
                mov	ax, 5555h		; Паттерн 01010101
                call	mem_test_cycle		; Тест
                jnz	short sub_exit		; Если ошибка – выход
                xor	ax, ax			; AX = 0 (паттерн "все нули")
		mov	AH,1			; ??? Лишняя инструкция? (возможно, для совместимости)
endp		Mem_test_pattern 





proc		mem_test_cycle near		; Цикл теста одного блока памяти
                mov     cx, [ds:mem_test_cycle_addr] ; CX = количество слов для теста (из переменной)
                xor	di, di			; DI = 0 (начало блока)
                rep stosw			; Заполнить блок значением AX
                mov     cx, [ds:mem_test_cycle_addr] ; Снова загрузить размер
                xor	di, di			; DI = 0
                repe scasw			; Сравнить блок со значением AX
                retn				; Возврат (ZF установлен, если совпало)
endp		mem_test_cycle


proc		print_backspace near		; Процедура печати нескольких пробелов (забой)
                mov	ax, 0E08h		; AL = 08h (backspace), функция телетайпа
		int	10h			; Вывести backspace
                loop	print_backspace	; Повторить CX раз

sub_exit:					; Точка выхода для подпрограмм
                retn				; Возврат
endp		print_backspace


;---------------------------------------------------------------------------------------------------
;  Print cpu and fpu type			; Заголовок: печать типа CPU и FPU
;---------------------------------------------------------------------------------------------------
proc		print_cpu_fpu near		; Процедура определения и печати процессора и сопроцессора
        	xor     al, al			; AL = 0
		mov	al, 40h			; AL = 40h
		mul	al			; AX = 40h * 40h = 1000h (для проверки V20)
		jz	@@have_v20		; Если результат 0 (флаг ZF установлен) – V20
		mov	si, offset str_8088	; Иначе – 8088
		call	print_string		; Вывести строку
		jmp	fpu			; Перейти к проверке FPU
@@have_v20:					; Метка для V20
		mov	si, offset str_v20	; Строка "V20"
		call	print_string		; Вывести

fpu:						; Проверка наличия сопроцессора
		mov	ax, BDAseg		; AX = 40h
		mov 	ds, ax			; DS = BDA
		fninit				; Инициализировать FPU (если есть)
		mov	si, 0200h		; SI = 200h (адрес в BDA)
		mov	[byte si+1], 0		; Обнулить байт по адресу SI+1
		fnstcw	[word si]		; Сохранить управляющее слово FPU в [SI]
		mov	ah, [si+1]		; AH = старший байт управляющего слова
		cmp	ah, 03h			; Должен быть 03h для реального FPU
		jne	@@no_8087		; Не совпадает – FPU отсутствует
		or	[byte ds:10h], 00000010b ; Установить бит FPU в слове оборудования
		mov	si, offset str_8087	; Строка " with Intel 8087 FPU"
		call 	print_string		; Вывести
		ret				; Возврат
@@no_8087:					; Нет FPU
		and	[byte ds:10h], 11111101b ; Сбросить бит FPU
		ret				; Возврат

endp		print_cpu_fpu
;-------------------------------------------------------------------------------------------------------




;----------------------------------------------------------------------------------------------------------
proc            print_string near               ; Процедура вывода строки на экран
print_string_loop:				; Цикл вывода
                lods    [byte ptr cs:si]	; Загрузить байт из CS:SI в AL
                or      al, al			; Проверить на 0 (конец строки)
                jz      short sub_exit		; Если 0 – выход
                mov     ah, 0Eh			; Функция телетайпа
                int     10h 			; Вывести символ
                jmp     short print_string_loop ; Повторить
endp            print_string

;-----------------------------------------------------------------------------------------------------------
; Convert AX to ASCII and print it		; Преобразовать AX в ASCII и вывести

proc		print_AX near			; Процедура вывода слова AX в шестнадцатеричном виде
                xchg	ah, al			; Обменять байты (сначала старший)
                call	print_AL		; Вывести старший байт
                xchg	ah, al			; Вернуть обратно (теперь младший)
endp		print_AX 

proc		print_AL near			; Процедура вывода байта AL (две шестнадцатеричные цифры)
                mov	cl, 4			; CL = 4 (число сдвигов)
                rol	al, cl			; Сдвинуть влево на 4 бита (старшая тетрада в младшую)
                call	print_AL_nibble	; Вывести старшую тетраду
                rol	al, cl			; Снова сдвинуть (вернуть исходное, теперь младшая тетрада)
endp		print_AL 

; Converts a binary number in AL, range 0 to 0FH ; Преобразует двоичное число в AL (0..F) в ASCII-символ
; to the appropriate ASCII character.
proc		print_AL_nibble near		; Вывод одной шестнадцатеричной цифры
                push	ax			; Сохранить AX
                and	al, 0Fh			; Оставить только младшие 4 бита
                add	al, 90h			; Специальная последовательность для преобразования hex->ASCII
                daa				; Десятичная коррекция
                adc	al, 40h			; Добавить 40h
                daa				; Вторая коррекция – получается символ '0'-'9','A'-'F'
                mov	ah, 0Eh			; Функция телетайпа
                int	10h			; Вывести символ
                pop	ax			; Восстановить AX
                retn				; Возврат
endp		print_AL_nibble

;--------------------------------------------------------------------------------------------------
; Print date					; Вывод даты
;--------------------------------------------------------------------------------------------------
proc		print_date	near		; Процедура вывода даты и приглашения

	 	mov	dl, 0h			; DL = 0 (колонка)
		mov	dh, 18h			; DH = 24 (строка 24)
		mov	ah, 02h			; Установить курсор
		int 	10h			; Вызов
		mov	si, enter_setup		; SI = строка "Press <DEL> to Enter Setup"
		call 	print_string		; Вывести
		mov	si, date_full		; SI = строка даты
		call	print_string		; Вывести
		xor 	dx, dx			; DX = 0 (верхний левый угол)
		mov 	ah, 02h			; Установить курсор
		int 	10h			; Вызов
		ret				; Возврат

endp		print_date
;--------------------------------------------------------------------------------------------------
; Flush string					; Очистка строки (не используется?)
;--------------------------------------------------------------------------------------------------
proc		flush_string	near		; Процедура заполнения строки пробелами
                mov 	cx, 50h			; CX = 50h (80 символов)
		mov	al, 20h			; AL = пробел
		mov	ah, 0ah			; Функция записи символов с атрибутом
		int 	10			; Вызов видео-прерывания (не 10h, ошибка? должно быть 10h)
		ret				; Возврат

endp		flush_string


;---------------------------------------------------------------------------------------------------
; Clear display screen				; Очистка экрана
;---------------------------------------------------------------------------------------------------
proc		clear_screen	near		; Процедура очистки экрана
	
		mov	dx, 184Fh		; Нижний правый угол (строка 24, колонка 79)
		xor	cx, cx			; Верхний левый угол (0,0)
		mov	ax, 600h			; Функция прокрутки окна вверх (очистка)
		mov	bh, 7				; Атрибут (белый на чёрном)
		int	10h				; Вызов
		mov	ah, 2				; Установить курсор
		xor	dx, dx			; Позиция (0,0)
		mov	bh, 0				; Страница 0
		int	10h				; Вызов
		mov	ax, 500h			; Установить активную страницу 0
		int	10h				; Вызов
		ret					; Возврат

endp		clear_screen

;---------------------------------------------------------------------------------------------------
; Saerch additional rom				; Поиск дополнительных ПЗУ
;---------------------------------------------------------------------------------------------------


proc		search_rom	near		; Процедура поиска дополнительных ПЗУ

                push    bx			; Сохранить регистры
                push    cx
                push    dx
                push	si
                push	di
                push	ds
                push	es
                mov	ax, BDAseg		; AX = 40h
                mov	ds, ax			; DS = BDA
                mov	[word ptr ds:gen_use_ptr_], 3 ; Установить указатель? (смещение 3)
                mov	[word ptr ds:gen_use_seg_], 0BE00h ; Начальный сегмент для поиска (BE00h)

search_loop:					; Цикл поиска
                mov	ax, BDAseg		; AX = 40h
                mov	ds, ax			; DS = BDA
                add	[word ptr ds:gen_use_seg_+1], 2 ; Увеличить сегмент на 2 (следующий блок 2 КБ)
                cmp	[word ptr ds:gen_use_seg_], 0FE00h ; Достигли конца области (FE00h)?
                jz	short no_additional_rom ; Да – нет больше ПЗУ
                mov	es, [word ptr ds:gen_use_seg_] ; ES = текущий сегмент для проверки
                assume es:nothing
                cmp	[word ptr es:0], 0AA55h ; Проверить сигнатуру ПЗУ (AA55h)
                jnz	short search_loop	; Не совпадает – продолжить
                call	[dword ptr ds:gen_use_ptr_] ; Вызвать ПЗУ (дальний вызов по сохранённому указателю)
		mov	es, bx			; ES = BX (сохранить?)
		mov	bl, 5 * 18		; BL = 90 (задержка 5 секунд при 18.2 Гц)

                jmp	short search_loop	; Продолжить поиск

no_additional_rom:				; Дополнительных ПЗУ нет
		pop	es			; Восстановить регистры
		pop	ds
		pop	di
		pop	si
                pop	dx
                pop	cx
                pop	bx
		ret				; Возврат
endp		search_rom	

;--------------------------------------------------------------------------------------------------
; PC speaker beep (length in bl)		; Гудок PC-спикера (длина в BL)
;--------------------------------------------------------------------------------------------------
proc		beep	near			; Процедура гудка

		push	ax			; Сохранить регистры
		push	cx
		mov	al, 10110110b		; Команда для таймера 8253: канал 2, режим 3, двоичный
		out	43h, al 		; Записать в командный регистр
		mov	ax, 528h			; Делитель частоты (примерно 904 Гц)
		out	42h, al 			; Младший байт
		mov	al, ah			; Старший байт
		out	42h, al 			; Записать
		in	al, 61h 			; Прочитать порт B PPI
		push	ax			; Сохранить состояние
		or	al, 00000011b		; Включить динамик (биты 0 и 1)
		out	61h, al 			; Записать
		xor	cx, cx			; CX = 0 (максимальная задержка)
@@delay:					; Внутренний цикл задержки
		loop	@@delay			; Повторить 65536 раз
		dec	bl			; Уменьшить BL
		jnz	@@delay			; Если не 0 – повторить (внешний цикл)
		pop	ax			; Восстановить исходное состояние порта
		out	61h, al 			; Выключить динамик
		pop	cx			; Восстановить регистры
		pop	ax
		ret				; Возврат

endp	beep


;--------------------------------------------------------------------------------------------------
; Waits for a keypress and then returns it (ah=scan code, al=ASCII)
; Ожидает нажатие клавиши и возвращает её (AH=скан-код, AL=ASCII)
;--------------------------------------------------------------------------------------------------
proc	get_key	near				; Процедура ожидания нажатия клавиши

	mov	ah, 0				; Функция чтения клавиши
	int	16h				; Вызов прерывания клавиатуры
	ret					; Возврат

endp	get_key

;--------------------------------------------------------------------------------------------------
; Print video type				; Вывод типа видеоадаптера
;--------------------------------------------------------------------------------------------------

proc    	video_type	near		; Процедура определения и вывода типа видео
		mov	ah, 12h			; Функция получения информации об EGA
		mov	bx, 0FF10h		; Параметр для определения EGA
		int	10h			; Вызов видео-прерывания
		cmp	bh, 0FFh			; Если BH остался FFh, то EGA отсутствует
		je	is_cga			; Равно – CGA
		mov	si, offset str_ega_vga	; Иначе EGA/VGA
		jmp	short display_video	; Вывести
is_cga:						; CGA
		mov	si, offset str_cga	; Строка для CGA
display_video:					; Вывод строки
		call	print_string		; Вывести строку
		ret				; Возврат
endp		video_type
;---------------------------------------------------------------------------------------------------
include int19h.asm 	; Warm Boot		; Подключение файла обработчика прерывания 19h (загрузка)
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int09h.asm 	; Keyboard Services IRQ1 ; Подключение обработчика клавиатуры (IRQ1)
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int16h.asm 	; Keyboard		; Подключение обработчика прерывания 16h (клавиатура)
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int14h.asm 	; RS232 Service	; Подключение обработчика последовательного порта
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int13h.asm 	; Floppydisk		; Подключение обработчика дисковода
;---------------------------------------------------------------------------------------------------
;include int13h_new.asm 	; Floppydisk
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int1Eh.asm 	; Diskette Parameter Table ; Подключение таблицы параметров дисковода
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int17h.asm 	; Parallel LPT Services ; Подключение обработчика параллельного порта
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int1Dh.asm	; Video parametr Table	; Подключение таблицы параметров видео
;---------------------------------------------------------------------------------------------------

; --------------------------------------------------------------------------------------------------
include int10h.asm 	; Interrupt 10h handlers ; Подключение обработчика видео
; --------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int12h.asm 	; Memory Size		; Подключение обработчика определения размера памяти
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int11h.asm  	; Equipment Check	; Подключение обработчика определения оборудования
;---------------------------------------------------------------------------------------------------

; --------------------------------------------------------------------------------------------------
include int1Ah.asm	; Real Time Clock Function ; Подключение обработчика часов реального времени
; --------------------------------------------------------------------------------------------------

; --------------------------------------------------------------------------------------------------
include int08h.asm	; IRQ0;			; Подключение обработчика таймера
; --------------------------------------------------------------------------------------------------

; --------------------------------------------------------------------------------------------------
include dummy.asm  	;Dummy interrupt	; Подключение заглушки прерывания
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int05h.asm  	;Print Screen		; Подключение обработчика печати экрана
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int68h.asm  	;Second interrupt table redirect 68h to 08h ; Перенаправление прерывания 68h на 08h
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int69h.asm  	;Second interrupt table redirect 69h to 09h and scannig keyboard key
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int6Ah.asm  	;Second interrupt table redirect 6Ah to 0Ah
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int6Bh.asm  	;Second interrupt table redirect 6Bh to 0Bh
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int6Ch.asm  	;Second interrupt table redirect 6Ch to 0Ch
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int6Dh.asm  	;Second interrupt table redirect 6Dh to 0Dh
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int6Eh.asm  	;Second interrupt table redirect 6Eh to 0Eh
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include int6Fh.asm  	;Second interrupt table redirect 6Fh to 0Fh
;---------------------------------------------------------------------------------------------------


;---------------------------------------------------------------------------------------------------
include gfx.asm		; Grafic charapter table ; Подключение таблицы графических символов
;---------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------
include vectors.asm  	;Interrupt vector tables ; Подключение таблиц векторов прерываний
;---------------------------------------------------------------------------------------------------

;--------------------------------------------------------------------------------------------------
; Power-On Entry Point  			; Точка входа при включении питания
;--------------------------------------------------------------------------------------------------
		entry   0FFF0h			; Макрос для размещения точки входа по адресу FFFF0h
proc		power	far			; Дальняя процедура power
                jmpfar	0F000h, warm_boot	; Дальний переход на warm_boot (в сегменте F000h)
endp 		power				; Конец процедуры

;--------------------------------------------------------------------------------------------------
; BIOS Release Date and Signature		; Дата выпуска BIOS и сигнатура
;--------------------------------------------------------------------------------------------------
date	db '12/04/20', 0			; Строка даты
		db 0FEh  			; Тип компьютера (FEh – XT)
ends		code				; Конец сегмента code
end						; Конец ассемблирования